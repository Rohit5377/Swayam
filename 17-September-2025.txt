
1. Search a 2D Matrix
You are given an m x n integer matrix matrix with the following two properties:
Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.
You must write a solution in O(log(m * n)) time complexity.
Example 1:
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Example 2:
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false


class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n=matrix.length, m=matrix[0].length;
        int st=0, end=n*m-1;
        while(st<=end){
            int mid=st+(end-st)/2;
            if(matrix[mid/m][mid%m]==target){
                return true;
            }
            else if(target>matrix[mid/m][mid%m]){
                st=mid+1;
            }else{
                end=mid-1;
            }
        }
        return false;
    }
}



2. Subsets II
Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:
Input: nums = [0]
Output: [[],[0]]


class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> list=new ArrayList<>();
        List<Integer> subset=new ArrayList<>();
        rec(nums,0,list,subset);
        return list;
    }
    public void rec(int[] nums, int index, List<List<Integer>> list, List<Integer> subset){
        if(index==nums.length){
            if(!list.contains(subset)){
                list.add(new ArrayList<>(subset));
            }
            return;
        }
        subset.add(nums[index]);
        rec(nums,index+1,list,subset);
        subset.remove(subset.size()-1);
        rec(nums,index+1,list,subset);
    }
}

3. Validate Binary Search Tree
Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys strictly less than the node's key.
The right subtree of a node contains only nodes with keys strictly greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
Input: root = [2,1,3]
Output: true
Example 2:
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


class Solution {
    public boolean isValidBST(TreeNode root) {
       ArrayList<Integer> list=new ArrayList<>();
       helper(root,list);
       for(int i=1;i<list.size();i++){
        if(list.get(i)<=list.get(i-1)) return false;
       }
       return true;
    }

    public void helper(TreeNode root,ArrayList<Integer> list){
        if(root==null) return;
        helper(root.left,list);
        list.add(root.val);
        helper(root.right,list);
    }
}



4. Maximum Depth of Binary Tree
Given the root of a binary tree, return its maximum depth.
A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3
Example 2:
Input: root = [1,null,2]
Output: 2


class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+height(root);
    }
    public int height(TreeNode root){
        if(root==null || (root.left==null && root.right==null)) return 0;
        return 1+Math.max(height(root.left),height(root.right));
    }
}